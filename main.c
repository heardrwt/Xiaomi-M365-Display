/*
  main.c
  
  Xiaomi M365 Display
  Copyright (c) 2018 Richard Heard. All rights reserved.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include "app_error.h"
#include "app_util_platform.h"
#include "nrf_delay.h"
#include "bsp.h"
#include "app_timer.h"
#include "nrf_drv_spi.h"
#include "nordic_common.h"
#include "ble_module.h"
#include "ssd1306.h"
#include "binary.h"
#include "softdevice_handler.h"

#define NRF_LOG_MODULE_NAME "APP"
#include "nrf_log.h"
#include "nrf_log_ctrl.h"

#include "ninebot_module.h"

#define DELAY_MS                 1000                /**< Timer Delay in milli-seconds. */

/*
 * This example uses only one instance of the SPI master.
 * Please make sure that only one instance of the SPI master is enabled in config file.
 */

#define APP_TIMER_PRESCALER      0                      /**< Value of the RTC1 PRESCALER register. */
#define APP_TIMER_MAX_TIMERS     BSP_APP_TIMERS_NUMBER  /**< Maximum number of simultaneously created timers. */
#define APP_TIMER_OP_QUEUE_SIZE  2                      /**< Size of timer operation queues. */

volatile bool change_rtc = false;
extern uint8_t time_buffer[128];

#define USE_METRIC 1 // kph vs mph etc.

// Display Config
#define SSD1306_CONFIG_VDD_PIN      28
#define SSD1306_CONFIG_SCL_PIN      3
#define SSD1306_CONFIG_SDA_PIN      4

// Button Config
#define BTN_ID_WAKEUP               1  /**< ID of button used to wake up the application. */
#define BTN_ID_SLEEP                1  /**< ID of button used to put the application into sleep mode. */
#define BTN_ACTION_SLEEP            BSP_BUTTON_ACTION_RELEASE    /**< Button action used to put the application into sleep mode. */

static void ssd1306_power_off(void);

/**@snippet [Handling events from the ble_nus_c module] */ 

/**@brief Function for putting the chip into sleep mode.
 *
 * @note This function will not return.
 */
static void sleep_mode_enter(void) {
  NRF_LOG_INFO("Calling sleep_mode_enter.\r\n");
  uint32_t err_code = bsp_indication_set(BSP_INDICATE_IDLE);
  APP_ERROR_CHECK(err_code);

  ssd1306_power_off();

  // Prepare wakeup buttons.
  err_code = bsp_wakeup_button_enable(BTN_ID_WAKEUP); 
  APP_ERROR_CHECK(err_code);

  // Go to system-off mode (this function will not return; wakeup will cause a reset).
  err_code = sd_power_system_off();
  APP_ERROR_CHECK(err_code);
}

/**@brief Function for handling events from the BSP module.
 *
 * @param[in]   event   Event generated by button press.
 */
void bsp_event_handler(bsp_event_t event) {
  uint32_t err_code;
  switch (event) {
  case BSP_EVENT_SLEEP:
    sleep_mode_enter();
    break;

  default:
    break;
  }
}

/**@brief Function for initializing bsp module.
 */
void bsp_configuration(void) {
    uint32_t err_code = NRF_SUCCESS;

    NRF_CLOCK->LFCLKSRC            = (CLOCK_LFCLKSRC_SRC_Xtal << CLOCK_LFCLKSRC_SRC_Pos);
    NRF_CLOCK->EVENTS_LFCLKSTARTED = 0;
    NRF_CLOCK->TASKS_LFCLKSTART    = 1;

    while (NRF_CLOCK->EVENTS_LFCLKSTARTED == 0) {
        // Do nothing.
    }

    APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_OP_QUEUE_SIZE, NULL);

    err_code = bsp_init(BSP_INIT_LED|BSP_INIT_BUTTONS, APP_TIMER_TICKS(100, APP_TIMER_PRESCALER), bsp_event_handler);
    APP_ERROR_CHECK(err_code);

    // configure our sleep button
    err_code = bsp_event_to_button_action_assign(BTN_ID_SLEEP, BTN_ACTION_SLEEP, BSP_EVENT_SLEEP);

}

void ssd1306_power_on(void) {
  nrf_gpio_pin_set(SSD1306_CONFIG_VDD_PIN); // vdd
  nrf_gpio_cfg(
      SSD1306_CONFIG_VDD_PIN,
      NRF_GPIO_PIN_DIR_OUTPUT,
      NRF_GPIO_PIN_INPUT_DISCONNECT,
      NRF_GPIO_PIN_NOPULL,
      NRF_GPIO_PIN_H0H1, // NRF_GPIO_PIN_S0S1,
      NRF_GPIO_PIN_NOSENSE);
  nrf_delay_ms(20);
}

void ssd1306_power_off(void) {
  nrf_gpio_pin_clear(SSD1306_CONFIG_VDD_PIN); // vdd
  nrf_gpio_cfg(
      SSD1306_CONFIG_VDD_PIN,
      NRF_GPIO_PIN_DIR_OUTPUT,
      NRF_GPIO_PIN_INPUT_DISCONNECT,
      NRF_GPIO_PIN_NOPULL,
      NRF_GPIO_PIN_H0H1, // NRF_GPIO_PIN_S0S1,
      NRF_GPIO_PIN_NOSENSE);
  nrf_delay_ms(20);
}

/** @brief Function for the Power manager.
 */
static void power_manage(void) {
  uint32_t err_code = sd_app_evt_wait();
  APP_ERROR_CHECK(err_code);
}

// Logos: https://www.dcode.fr/binary-image

#define BT_LOGO_W 32
#define BT_LOGO_H 32
static const unsigned char bt_logo [] = {
B00000000, B00000000, B00000000, B00000000,
B00000000, B00000000, B00000000, B00000000,
B00000000, B01100000, B00000000, B00000000,
B00000000, B01110000, B00000000, B00000000,
B00000000, B01111000, B00000000, B00000000,
B00000000, B01111100, B00000000, B00000000,
B00000000, B01101110, B00000000, B00000000,
B00000000, B01100111, B00000000, B01100000,
B00000000, B01100011, B10000000, B01110000,
B00001000, B01100001, B11000000, B00111000,
B00001100, B01100011, B10000000, B00011000,
B00001110, B01100111, B00000110, B00011100,
B00000111, B11111110, B00000111, B00001100,
B00000011, B11111100, B00000011, B00001110,
B00000001, B11111000, B00000011, B10001110,
B00000000, B11110000, B00000001, B10000110,
B00000000, B11110000, B00000001, B10001110,
B00000001, B11111000, B00000011, B10001110,
B00000011, B11111100, B00000011, B00001100,
B00000111, B01101110, B00000111, B00011100,
B00001110, B01100111, B00000110, B00011000,
B00001100, B01100011, B10000000, B00111000,
B00001000, B01100001, B11000000, B01110000,
B00000000, B01100011, B10000000, B01110000,
B00000000, B01100111, B00000000, B01100000,
B00000000, B01101110, B00000000, B00000000,
B00000000, B01111100, B00000000, B00000000,
B00000000, B01111000, B00000000, B00000000,
B00000000, B01110000, B00000000, B00000000,
B00000000, B01100000, B00000000, B00000000,
B00000000, B00000000, B00000000, B00000000,
B00000000, B00000000, B00000000, B00000000,
};

#define BAT_LOGO_W 16
#define BAT_LOGO_H 8
static const unsigned char bat_logo [] = {
B11111111, B11111110,
B10000000, B00000010,
B10111111, B11000011,
B10111111, B11000011,
B10111111, B11000011,
B10111111, B11000011,
B10000000, B00000010,
B11111111, B11111110,
};

#define SCOOTER_LOGO_W 32
#define SCOOTER_LOGO_H 32
static const unsigned char scooter_logo [] = {
  B00000000, B00000000, B00000000, B00000000,
  B00000000, B00000000, B00000000, B00000000,
  B00000000, B00000000, B00111111, B00000000,
  B00000000, B00000000, B00111111, B00000000,
  B00000000, B00000000, B00111111, B10000000,
  B00000000, B00000000, B00000011, B10000000,
  B00000000, B00000000, B00000011, B10000000,
  B00000000, B00000000, B00000011, B10000000,
  B00000000, B00000000, B00000001, B10000000,
  B00000000, B00000000, B00000001, B11000000,
  B00000000, B00000000, B00000001, B11000000,
  B00000000, B00000000, B00000001, B11000000,
  B00000000, B00000000, B00000000, B11000000,
  B00000000, B00000000, B00000000, B11100000,
  B00000000, B00000000, B00000000, B11100000,
  B00000000, B00000000, B00000000, B11100000,
  B00000000, B00000000, B00000000, B11100000,
  B00000000, B00000000, B00000001, B11100000,
  B00001111, B00000000, B00000001, B11110000,
  B00001111, B10000000, B00000011, B11110000,
  B00000001, B11000000, B00000011, B11110000,
  B00011000, B11100000, B00000111, B01111000,
  B01111110, B01100000, B00000111, B01111110,
  B01110111, B00110000, B00001110, B11111111,
  B11001111, B11111111, B11111110, B11111011,
  B11001111, B11111111, B11111100, B11011011,
  B11001111, B11111111, B11111100, B11000011,
  B11110111, B00000000, B00000000, B11101111,
  B01111110, B00000000, B00000000, B01111110,
  B00011100, B00000000, B00000000, B00111000,
  B00000000, B00000000, B00000000, B00000000,
  B00000000, B00000000, B00000000, B00000000,
};


//16x10
#define DIST_LOGO_W 16
#define DIST_LOGO_H 8
static const unsigned char dist_logo [] = {
  B11111111, B11111110,
  B10000000, B00000010,
  B10111111, B11111010,
  B10111111, B11111010,
  B10110110, B11011010,
  B10110110, B11011010,
  B10000000, B00000010,
  B11111111, B11111110,
};

void ninebot_data_updated_handler(ninebot_data_t *ninebot_data) {
  // Reset
  ssd1306_clear_display();
  ssd1306_set_textcolor(WHITE);
  ssd1306_set_cursor(0, 0);

  // Draw
  if (ninebot_data->connected) {
#if USE_METRIC
    // Speed - kph
    ssd1306_set_textsize(3);
    int length = ssd1306_printf_length("%.1lf", ninebot_data->speed_kph);
    uint16_t x = (ssd1306_width() - (length * ssd1306_char_width())) / 2;
    // Ensure that negative values don't jump around
    if (ninebot_data->speed_kph < 0.0) {
      x -= (ssd1306_char_width() / 2);
    }
    uint16_t y = 0;
    ssd1306_set_cursor(x, y);
    ssd1306_printf("%.1lf", ninebot_data->speed_kph);
    ssd1306_set_textsize(1);
    ssd1306_printf("km/h");
#else
    // Speed - mph
    ssd1306_set_textsize(3);
    int length = ssd1306_printf_length("%.1lf", ninebot_data->speed_mph);
    uint16_t x = (ssd1306_width() - (length * ssd1306_char_width())) / 2;
    // Ensure that negative values don't jump around
    if (ninebot_data->speed_mph < 0.0) {
      x -= (ssd1306_char_width() / 2);
    }
    uint16_t y = 0;
    ssd1306_set_cursor(x, y);
    ssd1306_printf("%.1lf", ninebot_data->speed_mph);
    ssd1306_set_textsize(1);
    ssd1306_printf("mph");
#endif

    // Battery Icon
    ssd1306_draw_bitmap(0, 50, bat_logo, BAT_LOGO_W, BAT_LOGO_H, WHITE);

    // Battery Percentage
    ssd1306_set_textsize(1);
    ssd1306_set_cursor(19, 50);
    double percent = 100.0d * ninebot_data->battery_percentage;
    ssd1306_printf("%.0lf%%", percent);

    // Battery Bar + Ticks
    uint16_t y12 = ssd1306_height();
    uint16_t x2 = (int)((double)ssd1306_width() * ninebot_data->battery_percentage);
    ssd1306_draw_line(0, --y12, x2, y12, WHITE);
    ssd1306_draw_pixel(32, y12, BLACK);
    ssd1306_draw_pixel(64, y12, BLACK);
    ssd1306_draw_pixel(96, y12, BLACK);

    ssd1306_draw_line(0, --y12, x2, y12, WHITE);
    ssd1306_draw_pixel(32, y12, BLACK);
    ssd1306_draw_pixel(64, y12, BLACK);
    ssd1306_draw_pixel(96, y12, BLACK);

// Distance Remaining
#if USE_METRIC
    ssd1306_set_textsize(1);
    length = ssd1306_printf_length("%.0lfkm", ninebot_data->distance_remaining_km);
    x = ssd1306_width() - (length * ssd1306_char_width());
    y = 50;
    ssd1306_set_cursor(x, y);
    ssd1306_printf("%.0lfkm", ninebot_data->distance_remaining_km);
#else
    ssd1306_set_textsize(1);
    length = ssd1306_printf_length("%.0lfmi", ninebot_data->distance_remaining_mi);
    x = ssd1306_width() - (length * ssd1306_char_width());
    y = 50;
    ssd1306_set_cursor(x, y);
    ssd1306_printf("%.0lfmi", ninebot_data->distance_remaining_mi);
#endif

    // Distance logo
    ssd1306_draw_bitmap(x - DIST_LOGO_W - 3, 50, dist_logo, DIST_LOGO_W, DIST_LOGO_H, WHITE);

  } else {
    // Scooter Logo + Searching text
    ssd1306_draw_bitmap(48, 14, scooter_logo, SCOOTER_LOGO_W, SCOOTER_LOGO_H, WHITE);
    ssd1306_set_textsize(1);
    ssd1306_set_cursor((ssd1306_width() - (ssd1306_char_width() * 9)) / 2, ssd1306_height() - ssd1306_char_height());
    ssd1306_putstring("Searching..");
  }

  ssd1306_display();
}

/**@brief Function for application main entry. Does not return. */
int main(void) {
  APP_ERROR_CHECK(NRF_LOG_INIT(NULL));
  NRF_LOG_INFO("Main init...\r\n");
  NRF_LOG_FLUSH();

  // Setup bsp module.
  bsp_configuration();
  NRF_LOG_FLUSH();

  // display
  ssd1306_power_on();
  ssd1306_init_i2c(SSD1306_CONFIG_SCL_PIN, SSD1306_CONFIG_SDA_PIN);
  ssd1306_begin(SSD1306_SWITCHCAPVCC, SSD1306_I2C_ADDRESS, false);

  // Initial display state
  ssd1306_clear_display();
  ssd1306_display();

  // Initial Boot Logo
  ssd1306_draw_bitmap(48, 14, scooter_logo, SCOOTER_LOGO_W, SCOOTER_LOGO_H, WHITE);
  ssd1306_set_textcolor(WHITE);
  ssd1306_set_textsize(1);
  char* message = "RH 2018";
  ssd1306_set_cursor((ssd1306_width()-(ssd1306_char_width() * strlen(message)))/2, ssd1306_height() - ssd1306_char_height());
  ssd1306_printf(message);
  ssd1306_display();
  nrf_delay_ms(500);

  // BLE
  ble_stack_init();

  // Nordic uart service
  nus_c_init();

  // Ninebot init
  ninebot_init(ninebot_data_updated_handler);

  // Start scanning for peripherals and initiate connection
  // with devices that advertise NUS UUID.
  nrf_delay_ms(10);
  NRF_LOG_INFO("Calling scan_start.\r\n");
  scan_start();

  while (1) {
    power_manage();
    NRF_LOG_FLUSH();
  }

}

/** @} */